/*
 * ocfs2_err.c:
 * This file is automatically generated; please do not edit it.
 */

#include <stdlib.h>

#define N_(a) a

static const char * const text[] = {
	N_(	"Device name specified was not found"),
	N_(	"Illegal or malformed device name"),
	N_(	"I/O error on channel"),
	N_(	"Attempt to read block from filesystem resulted in short read"),
	N_(	"Attempt to write block to the filesystem resulted in short write"),
	N_(	"Memory allocation failed"),
	N_(	"Invalid argument passed to OCFS2 library"),
	N_(	"Device contains an OCFS volume"),
	N_(	"Bad magic number in superblock"),
	N_(	"Filesystem has unexpected block size"),
	N_(	"The OCFS2 superblock is corrupt"),
	N_(	"Unsupported feature(s) found"),
	N_(	"Unsupported read-only feature(s) found"),
	N_(	"Conflicting features specified"),
	N_(	"Bad magic number in inode"),
	N_(	"Invalid block number"),
	N_(	"Attempt to write to filesystem opened read-only"),
	N_(	"Journal must be at least 1024 blocks"),
	N_(	"Bad magic number in journal superblock"),
	N_(	"Invalid revoke record in journal"),
	N_(	"Invalid block tag in journal"),
	N_(	"Inode is not valid (active)"),
	N_(	"Inode type does not contain extents"),
	N_(	"Bad magic number in extent block"),
	N_(	"Extent block is corrupt"),
	N_(	"OCFS2 directory corrupted"),
	N_(	"OCFS2 inode is not a directory"),
	N_(	"Directory entry not found"),
	N_(	"File not found by ocfs2_lookup"),
	N_(	"No free space in the directory"),
	N_(	"Bit does not exist in bitmap range"),
	N_(	"Internal logic faliure"),
	N_(	"Bad magic number in group descriptor"),
	N_(	"Group descriptor is corrupt"),
	N_(	"Chain allocator is corrupt"),
	N_(	"Invalid range passed to extent map lookup"),
	N_(	"No mapping exists for the given extent range"),
	N_(	"Duplicate block discovered"),
	N_(	"Unable to find available bit"),
	N_(	"Attempting to free unallocated region"),
	N_(	"Unable to expand directory"),
	N_(	"No space available"),
	N_(	"Iteration complete"),
	N_(	"Too many symbolic links encountered"),
	N_(	"Invalid heartbeat file"),
	N_(	"Unknown filesystem"),
	N_(	"The block size is smaller than the sector size on this device"),
	N_(	"The lock name is invalid"),
	N_(	"Can't find ionice"),
	N_(	"Backup superblock not found"),
	N_(        "Too many slots for slot map"),
	N_(	"Can't write the data inline"),
	N_(	"Bad magic number in directory block"),
	N_(	"Bad magic number in xattr block"),
	N_(	"Unknown feature"),
	N_(	"Quota file is corrupted"),
	N_(	"Cannot determine sector size"),
	N_(	"Trying to rebalance empty leaf for indexed dir"),
	N_(	"Freeing non-empty quota hash"),
    0
};

struct error_table {
    char const * const * msgs;
    long base;
    int n_msgs;
};
struct et_list {
    struct et_list *next;
    const struct error_table * table;
};
extern struct et_list *_et_list;

const struct error_table et_ocfs_error_table = { text, -1512559360L, 59 };

static struct et_list link = { 0, 0 };

void initialize_ocfs_error_table_r(struct et_list **list);
void initialize_ocfs_error_table(void);

void initialize_ocfs_error_table(void) {
    initialize_ocfs_error_table_r(&_et_list);
}

/* For Heimdal compatibility */
void initialize_ocfs_error_table_r(struct et_list **list)
{
    struct et_list *et, **end;

    for (end = list, et = *list; et; end = &et->next, et = et->next)
        if (et->table->msgs == text)
            return;
    et = malloc(sizeof(struct et_list));
    if (et == 0) {
        if (!link.table)
            et = &link;
        else
            return;
    }
    et->table = &et_ocfs_error_table;
    et->next = 0;
    *end = et;
}
